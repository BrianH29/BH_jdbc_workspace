package com.kh.model.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

import com.kh.model.vo.Member;

public class MemberDao {
	
	/*
	 *  * Statement와 PreparedStatement의 차이점 (상속 구조 --> 방향)
	 *  - Statement 같은 경우 완성된 sql 문을 바로 실행하는 객체 (sql문을 완성형태로 만들어 둬야됨!!)
	 *  - PreparedStatement 같은 경우 미완성된 sql문을 잠시 보관해둘 수 있는 객체
	 *    해당 sql문 샐행하기 전 완성형태로 만든 후 실행하면됨
	 *    
	 *  * 기존의 Statement 방식 
	 *  Connection 객체를 통해  Statement 객체 생성 stmt = conn.createStatement(); 
	 *  Statement 객체를 통행 완성된 sql문을 실행 및 결과 : 결과 = stmt.executeXXX(완성된sql); 
	 *  ---------------------------------------------------------------------------------------
	 *  
	 *  * PreparedStatement 방식
	 *  Connection 객체를 통해 PreparedStatement 객체 생성
	 *  			(단, 미완성된 sql문을 담은채로 생성) 	: pstmt = conn.prepareStatement(미완성된 sql);
	 *  PreparedStatement 에서 제공하는 메소드를 통해 완성형태로 : pstmt.setXXX(1, "대체할값"); ....
	 *  그리고 나서 해당 완성된 sql문 실행 및 결과 				: 결과 : pstmt.executeXXX(); 
	 * 
	 */
	
	public void insertMember(Member m) { // insert문 --> 처리된 행의 갯수(int)
		int result = 0; 
		
		Connection conn = null;
		PreparedStatement pstmt = null;
		
		//실행하고자 하는 sql문 미완성된 형태로 둘 수 있음!! --> 미리 사용자가 입력한 값들 들어갈 수 있게 공간(?)만 확보!!
		String sql = "INSERT INTO MEMBER VALUES(SEQ_USERNO.NEXTVAL,?,?,?,?,?,?,?,?,?,SYSDATE)";
		
		try {
			Class.forName("oracle.jdbc.driver.OracleDriver");
			conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe","JDBC","JDBC");
			
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
		
		
	}//e.insertMember

}






